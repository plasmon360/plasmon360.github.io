<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Bala Juluri's Blog - Test Equipment</title><link href="plasmon360.github.io/" rel="alternate"></link><link href="plasmon360.github.io/feeds/test-equipment.atom.xml" rel="self"></link><id>plasmon360.github.io/</id><updated>2015-04-11T12:44:00-07:00</updated><subtitle>Ramblings</subtitle><entry><title>Hacking Weighing Scale to Upload Weight to Plotly using Raspberry Pi</title><link href="plasmon360.github.io/hacking-weighing-scale-to-upload-weight-to-plotly-using-raspberry-pi.html" rel="alternate"></link><published>2015-04-11T12:44:00-07:00</published><updated>2015-04-11T12:44:00-07:00</updated><author><name>juluribk</name></author><id>tag:None,2015-04-11:plasmon360.github.io/hacking-weighing-scale-to-upload-weight-to-plotly-using-raspberry-pi.html</id><summary type="html">&lt;p&gt;&lt;img alt="Weighing scale" class="aligncenter size-full wp-image-1512" height="228" src="http://juluribk.com/wp-content/uploads/2015/04/Picture7.png" width="902"&gt;&lt;/p&gt;
&lt;p&gt;I have been interested in monitoring and keep track of my weight. In the past, I have used phone apps for this purpose, works OK but I was thinking of reading weight information using some microcontroller from my weighing scale and upload the data to an online database. That means …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="Weighing scale" class="aligncenter size-full wp-image-1512" height="228" src="http://juluribk.com/wp-content/uploads/2015/04/Picture7.png" width="902"&gt;&lt;/p&gt;
&lt;p&gt;I have been interested in monitoring and keep track of my weight. In the past, I have used phone apps for this purpose, works OK but I was thinking of reading weight information using some microcontroller from my weighing scale and upload the data to an online database. That means that microcontroller should connect to my wi-fi connection at home and upload the data. I have seen some projects online that use an arduino for this purpose. They use arduino to serially send information to computer. The information on the computer can be potentially sent to an online database. One could also upload data directly from arduino to internet using a wifi shield, but this makes it more expensive. I was therefore more inclined towards Raspberry pi because it connects to wifi easily and can read data from weighing scale. I was also inclined in programming in python on raspberry pi rather than C, which I am not very proficient.&lt;/p&gt;
&lt;p&gt;Choice of weighing scale: I looked around some projects online and found a weighing scale here (&lt;a href="http://fivevolt.blogspot.com/2011/01/hacking-scale-to-add-zigbee-goodness.html"&gt;http://fivevolt.blogspot.com/2011/01/hacking-scale-to-add-zigbee-goodness.html&lt;/a&gt;) that seemed easy to get data from by reading the LED signals. I bought the same model for around 20 bucks at my local target. The first thing I notice after opening this scale was that it did not look similar to what was described at fivevolt blog. I did not see the four transistors and HC164 of which the author talks about in his blog. May be the manufacturer changed the design or they have different versions of it. I was disappointed.&lt;/p&gt;
&lt;p&gt;The PCB on the weighing scale had a epoxy covered region, which I presume is the microcontroller and it is connected to a big chip on the board. I looked at the name of the big chip on the pcb board and I can barely read TM1628. A simple google search revealed that it was an LED controller for the led display. The led display has four grids (digits). Each of this digit is a 8 segment display . TM1628 controls which grids and segments were to be lit or not (HI or LOW) . So I can see 12 wires going from LED controller to LED display ( four for grids and 8 for the 7 segment display). I could figure out which wires correspond to which grid and which segment and tried to solder wires. But that meant I have to read 12 digital signals (Hi or Low) using raspberry pi GPIO. This also looks very ugly too. So I decided to take a different route instead.&lt;/p&gt;
&lt;p&gt;A close inspection revealed that the microcontroller onboard was sending instructions to TM1628 with SPI protocol. So I intercept the voltage pulses (3.3V) using Raspberry Pi as shown in figure below. SPI bus consists of master and slave and has four lines in between them, which are MOSI, MISO, SCLK and SS (for more information see https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi).  In this case, the TM1628 is the slave and the microcontroller on board is the master. The slave does not send any data to the microcontroller so there is no MISO line. SCLK is the clock signal. MOSI and SS line are referred as DIO and STB respectively in the TM1628 manual.&lt;/p&gt;
&lt;p&gt;[caption id="attachment_1521" align="aligncenter" width="780"]&lt;a href="http://juluribk.com/wp-content/uploads/2015/04/Picture11.png"&gt;&lt;img alt="Picture1" class="wp-image-1521 size-large" height="532" src="http://juluribk.com/wp-content/uploads/2015/04/Picture11-1024x698.png" width="780"&gt;&lt;/a&gt; Schematic of the hacked weighing scale[/caption]&lt;/p&gt;
&lt;p&gt;After intercepting the STB, SCLK and DIO with raspberry pi as shown in the above figure, I used bitscope () to read these signals. A type pattern looks like this:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://juluribk.com/wp-content/uploads/2015/04/Picture2.png"&gt;&lt;img alt="Picture2" class="aligncenter size-large wp-image-1502" height="439" src="http://juluribk.com/wp-content/uploads/2015/04/Picture2-1024x576.png" width="780"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Each green line in the DIO contains data that is synced to STB and SCLK. When I zoom on the each green line I see the following:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://juluribk.com/wp-content/uploads/2015/04/Picture3.png"&gt;&lt;img alt="Picture3" class="aligncenter size-large wp-image-1503" height="440" src="http://juluribk.com/wp-content/uploads/2015/04/Picture3-1024x577.png" width="780"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Bits of data are being sent out in the DIO line at the rising edge of the clock signal.To decode these bytes, I wrote a python program ([source code link at the bottom of this post]{style="color: #ff0000;"}) that would capture those bits very fast using &lt;a href="http://abyz.co.uk/rpi/pigpio/python.html"&gt;PIGPIO&lt;/a&gt; library. When I just step on the weighing scale and get down, weighing scale displayed “0.0” for some time and then the display turns off. I was able to get the bytes for this action and start to decode according to the TM1628 manual. Below are the bytes being sent and the decoded information for the action of just stepping on and stepping of the weighing scale.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://juluribk.com/wp-content/uploads/2015/04/Picture4.png"&gt;&lt;img alt="Order of commands being sent" class="aligncenter size-large wp-image-1504" height="660" src="http://juluribk.com/wp-content/uploads/2015/04/Picture4-1024x866.png" width="780"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Command 1 and command 2 prepare the display. Command3 helps in preparing the grid/digit. It can be seen from the above figure, once a grid is prepared, a character is being written to that grid/digit. This process starts from the first grid and ends at the fifth grid. This cycle repeats many times. The cycle repeats so fast that we think the display is not changing.  I used the following cheat sheets for decoding the above data bytes. Following table is for command 3 where a certain grid/digit has to being chosen.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://juluribk.com/wp-content/uploads/2015/04/Picture6.png"&gt;&lt;img alt="Grid command" class="aligncenter wp-image-1506" height="268" src="http://juluribk.com/wp-content/uploads/2015/04/Picture6.png" width="790"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Following table is the bytes for displaying a certain character on a certain grid/digit&lt;/p&gt;
&lt;p&gt;&lt;a href="http://juluribk.com/wp-content/uploads/2015/04/Picture5.png"&gt;&lt;img alt="Decoding the bytes on weighing scale" class="aligncenter wp-image-1505" height="790" src="http://juluribk.com/wp-content/uploads/2015/04/Picture5.png" width="714"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Once I understood the commands being sent and how to interpret them, i wrote a python code that uses &lt;a href="http://abyz.co.uk/rpi/pigpio/python.html"&gt;PIGPIO&lt;/a&gt; to read these commands. I also added the capability to select a user with a rotary switch and assign weight information. A user can be guest, myself or my wife. Weight information is written to a file. Finally I also added code to upload the file to plotly for visualization.&lt;/p&gt;
&lt;p&gt;This is my final product&lt;/p&gt;
&lt;p&gt;[caption id="attachment_1510" align="aligncenter" width="596"]&lt;a href="http://juluribk.com/wp-content/uploads/2015/04/IMG_20150411_120429.jpg"&gt;&lt;img alt="IMG_20150411_120429" class="wp-image-1510" height="447" src="http://juluribk.com/wp-content/uploads/2015/04/IMG_20150411_120429.jpg" width="596"&gt;&lt;/a&gt; Hacked Weighing scale and control box[/caption]&lt;/p&gt;
&lt;p&gt;[caption id="attachment_1511" align="aligncenter" width="622"]&lt;a href="http://juluribk.com/wp-content/uploads/2015/04/IMG_20150411_120439.jpg"&gt;&lt;img alt="IMG_20150411_120439" class="wp-image-1511" height="467" src="http://juluribk.com/wp-content/uploads/2015/04/IMG_20150411_120439.jpg" width="622"&gt;&lt;/a&gt; Housing for Raspberry pi and Rotarty switch[/caption]&lt;/p&gt;
&lt;p&gt;&lt;a href="http://juluribk.com/wp-content/uploads/2015/04/Picture7.png"&gt;Below is the youtube video of how the program works (without plotly integration)&lt;br&gt;
&lt;iframe src="https://www.youtube.com/embed/KuFBi6P7Lm8" width="420" height="315" frameborder="0" allowfullscreen="allowfullscreen"&gt;&lt;/iframe&gt;&lt;br&gt;
Below is an image of my weight on plotly since last year. I am still overweight :(&lt;br&gt;
&lt;/a&gt;[&lt;a href="http://juluribk.com/wp-content/uploads/2015/04/plotly_image.png"&gt;&lt;img alt="plotly_image" class="aligncenter wp-image-1507" height="464" src="http://juluribk.com/wp-content/uploads/2015/04/plotly_image.png" width="727"&gt;&lt;/a&gt;]{style="color: #ff0000;"}&lt;/p&gt;
&lt;h2 id="python-source-code-can-be-downloaded-here." style="text-align: center;"&gt;[ [P&lt;a href="https://gist.github.com/plasmon360/ab314441efec4c7b4298"&gt;ython Source code can be downloaded here&lt;/a&gt;.]{style="text-decoration: underline;"}]{style="color: #ff0000;"}&lt;/h2&gt;</content><category term="Test Equipment"></category><category term="python"></category></entry><entry><title>Controlling Newport 1918 Power Meter with Python</title><link href="plasmon360.github.io/newport-1918-power-meter-with-python.html" rel="alternate"></link><published>2015-04-04T12:23:00-07:00</published><updated>2015-04-04T12:23:00-07:00</updated><author><name>juluribk</name></author><id>tag:None,2015-04-04:plasmon360.github.io/newport-1918-power-meter-with-python.html</id><summary type="html">&lt;p&gt;&lt;a href="http://juluribk.com/wp-content/uploads/2015/04/23632.jpg"&gt;&lt;img alt="Newport 1918 power meter" class="aligncenter size-medium wp-image-1456" height="225" src="http://juluribk.com/wp-content/uploads/2015/04/23632-300x225.jpg" width="300"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Optical power meters in-conjunction with a detector are used to measure power from a laser source or monochromatic output. At work, we use &lt;a href="http://www.newport.com/Optical-Power-Meter-High-Performance-Hand-Held-19/509478/1033/info.aspx" title="Newport 1918"&gt;Newport 1918&lt;/a&gt; power meter. This power meter comes with its own &lt;a href="http://www.newport.com/Optical-Power-Meter-High-Performance-Hand-Held-19/509478/1033/info.aspx#tab_Literature" title="software"&gt;software&lt;/a&gt;. However, I was interested in controlling this instrument with python. I made a class for …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://juluribk.com/wp-content/uploads/2015/04/23632.jpg"&gt;&lt;img alt="Newport 1918 power meter" class="aligncenter size-medium wp-image-1456" height="225" src="http://juluribk.com/wp-content/uploads/2015/04/23632-300x225.jpg" width="300"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Optical power meters in-conjunction with a detector are used to measure power from a laser source or monochromatic output. At work, we use &lt;a href="http://www.newport.com/Optical-Power-Meter-High-Performance-Hand-Held-19/509478/1033/info.aspx" title="Newport 1918"&gt;Newport 1918&lt;/a&gt; power meter. This power meter comes with its own &lt;a href="http://www.newport.com/Optical-Power-Meter-High-Performance-Hand-Held-19/509478/1033/info.aspx#tab_Literature" title="software"&gt;software&lt;/a&gt;. However, I was interested in controlling this instrument with python. I made a class for this instrument . If you are interested you can download it at my &lt;strong&gt;&lt;a href="https://github.com/plasmon360/python_newport_1918_powermeter" title="Documentation and Github Repositry"&gt; Github repostitory&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;This python module contains higher level functions to communicate with &lt;a href="http://www.newport.com/1918-R-HandHeld-Optical-Power-and-Energy-Meter/509478/1033/info.aspx#tab_Overview"&gt;Newport 1918 power meter&lt;/a&gt; on a Windows computer. It uses python ctypes to access methods in the Newport's usbdll.dll driver.&lt;/p&gt;
&lt;p&gt;For connecting the hardware to the computer, see the &lt;a href="http://assets.newport.com/webDocuments-EN/images/RevA1918-RPowerMeterUsersManual.pdf"&gt;reference manual&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a class="anchor" href="https://github.com/plasmon360/python_newport_1918_powermeter#installing-the-powermeter-and-usbdriver" id="user-content-installing-the-powermeter-and-usbdriver"&gt;&lt;/a&gt;Installing the powermeter and usbdriver&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://assets.newport.com/webDocuments-EN/images/Computer_Interface_Software_v3.0.2.zip"&gt;Click here to download the newport powermeter Application and driver&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;On a 32 bit computer:&lt;ol&gt;
&lt;li&gt;Unzip the file&lt;/li&gt;
&lt;li&gt;Install the drivers and the power application found PowerMeter 3.0.2\win32&lt;/li&gt;
&lt;li&gt;run both PMSetup32.msi and USBDriverSetup32.msi (in sub folder). This should install drivers and the newport powermeter application at C:\Program Files\Newport&lt;/li&gt;
&lt;li&gt;LIBNAME (argument that is needed to intialize the instrument) in the case will be r'C:\Program Files\Newport\Newport USB Driver\Bin\usbdll.dll'&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;On a 64 bit computer:&lt;ol&gt;
&lt;li&gt;Unzip the file.&lt;/li&gt;
&lt;li&gt;Install the drivers and the power application found PowerMeter 3.0.2\x86Onx64&lt;/li&gt;
&lt;li&gt;run both PMSetup32on64.msi and USBDriverSetup32on64.msi (in sub folder). This should install drivers and the newport powermeter application at C:\Program Files (x86)\Newport&lt;/li&gt;
&lt;li&gt;LIBNAME (argument that is needed to intialize the instrument) in the case will be r'C:\Program Files (x86)\Newport\Newport USB Driver\Bin\usbdll.dll'&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Before you run the python module, make sure that you can run the newport powermeter application. This will ensure that the drivers are installed properly and there is no problem communicating with the instrument.&lt;/p&gt;
&lt;h2&gt;&lt;a class="anchor" href="https://github.com/plasmon360/python_newport_1918_powermeter#getting-the-product-id" id="user-content-getting-the-product-id"&gt;&lt;/a&gt;Getting the Product ID&lt;/h2&gt;
&lt;p&gt;The variable "product_id" is needed to intialize the instrument. For my case, the product_id was 0xCEC7. I am not sure if this will change on another computer. To find the product_id or PID,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Open the Windows Device Manager&lt;/li&gt;
&lt;li&gt;Expand the Human Interface Devices node&lt;/li&gt;
&lt;li&gt;Double-click the device of interest -- the USB Human Interface Device Properties window appears&lt;/li&gt;
&lt;li&gt;Click the Details tab.&lt;/li&gt;
&lt;li&gt;In the Property drop-down box, select Hardware Ids. The product id is some thinglike PID_ABC1, then use product_id = 0xABC1.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href="http://thecurlybrace.blogspot.com/2010/07/how-to-find-usb-device-vendor-and.html"&gt;See Here fore more detailed explaination !&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a class="anchor" href="https://github.com/plasmon360/python_newport_1918_powermeter#additional-notes" id="user-content-additional-notes"&gt;&lt;/a&gt;Additional notes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;There are many methods in the usbdll.dll, you can see all the methods in &lt;a href="https://github.com/plasmon360/python_newport_1918_powermeter/blob/master/NewpDll.h"&gt;NewPDll.h&lt;/a&gt;. The methods I use to connect/disconnection and read/write commands are:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;newp_usb_init_system - this function opens all USB instruments.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;newp_usb_get_device_info - this function retrieves the USB address of all open instruments.&lt;/li&gt;
&lt;li&gt;newp_usb_get_ascii - this function reads the response data from an instrument.&lt;/li&gt;
&lt;li&gt;newp_usb_send_ascii - this function sends the passed in command to an instrument.&lt;/li&gt;
&lt;li&gt;newp_usb_send_binary - this function sends the passed in binary data to an instrument.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;newp_usb_uninit_system - this function closes all USB instruments.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A full list of commands that can be sent to the instrument can be found in the &lt;a href="http://assets.newport.com/webDocuments-EN/images/RevA1918-RPowerMeterUsersManual.pdf"&gt;reference manual&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content><category term="Test Equipment"></category><category term="Instrumentation"></category><category term="python"></category></entry><entry><title>Controlling SP2150i monochromator with Python/PyVisa</title><link href="plasmon360.github.io/controlling-sp2150i-monochromator-with-pythonpyvisa.html" rel="alternate"></link><published>2014-09-19T18:28:00-07:00</published><updated>2014-09-19T18:28:00-07:00</updated><author><name>juluribk</name></author><id>tag:None,2014-09-19:plasmon360.github.io/controlling-sp2150i-monochromator-with-pythonpyvisa.html</id><summary type="html">&lt;p&gt;Monochromator is used in optics research where a narrow bandwidth of light is required to be illuminated on a sample. I work with Princeton Instruments Acton SP2150i and needed a python program to control it.&lt;/p&gt;
&lt;p&gt;I found the manual &lt;a href="ftp://ftp.princetoninstruments.com/public/Manuals/Acton/SP-2150i.pdf"&gt;here&lt;/a&gt; and on page 9-10, I saw the serial commands for …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Monochromator is used in optics research where a narrow bandwidth of light is required to be illuminated on a sample. I work with Princeton Instruments Acton SP2150i and needed a python program to control it.&lt;/p&gt;
&lt;p&gt;I found the manual &lt;a href="ftp://ftp.princetoninstruments.com/public/Manuals/Acton/SP-2150i.pdf"&gt;here&lt;/a&gt; and on page 9-10, I saw the serial commands for various functions (such as changing filters, moving the grating, etc).&lt;/p&gt;
&lt;p&gt;To control the instrument with my windows computer, I followed these steps:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1) Connect a usb cable between SP2150 and a computer&lt;/strong&gt;&lt;br&gt;
I used the port "USB" and not the "USB hub".&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2) Installing the monochromator drivers and Monocontrol software:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Turned on the monochromator and when prompted, I Installed Princeton Instruments VCP drivers (version 2.08.08). These drivers should be in Acton Monochromator Control Software installation Disk.  If the drivers are installed properly, you should see the monochromator as a Princeton Instruments Spectral device(COMx), in the device manager. x could be any number.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://juluribk.com/wp-content/uploads/2014/09/device_manager_11.png"&gt;&lt;img alt="device_manager_1" class="aligncenter" height="414" src="http://juluribk.com/wp-content/uploads/2014/09/device_manager_11.png" width="575"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Before attempting to control the instrument with python/pyvisa, I checked if the computer can communicate with monochromator using  "MonoControl". See the installation instructions &lt;a href="ftp://ftp.princetoninstruments.com/public/Manuals/Acton/Monochromator_Control_Software_Manual.pdf"&gt;here&lt;/a&gt; . Monocontrol allows for control of monochromator which will open a windows like this:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://juluribk.com/wp-content/uploads/2014/09/monocontrol1.png"&gt;&lt;img alt="monocontrol1" class="wp-image-1322 aligncenter" height="410" src="http://juluribk.com/wp-content/uploads/2014/09/monocontrol1.png" width="512"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;If you cannot reach this stage, then there is some problem with drivers and need to be fixed before you can use python/pyvisa to control the instrument. Close this software if you want to use it with pyvisa.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3) Install NI-VISA runtime &lt;/strong&gt;&lt;br&gt;
I downloaded the exe from National Instruments and installed it. This should provide the required visa32.dll&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4) Install python2.7 and Pyvisa &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;You can install pyvisa using Pip&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5) Python code&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I wrote a module that can be used to control the monochromator using pyvisa commands. The module provides a class definition and some high level functions. For the line, "self.m=instrument('COM7', timeout = 10)", change 7 to the right com port number. The number should match the com port number shown in the device manager. This module can be loaded into other python codes and the high level functions can be used to write even higher level functions (for example, see the code after if __name__ == "__main__":) . The specifics of the code are valid for the set of filters,turrets and gratings I use in my instrument, but the program can be used for other cases with slight modifications. You can also download the code &lt;a href="http://juluribk.com/wp-content/uploads/2014/09/SP2150i.txt"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em id="__mceDel"&gt; [cc lang="python"]&lt;br&gt;
"""&lt;br&gt;
Created on Fri Sep 19 18:11:40 2014&lt;/p&gt;
&lt;p&gt;@author: Bala Krishna Juluri&lt;br&gt;
"""&lt;/p&gt;
&lt;p&gt;from visa import *&lt;br&gt;
import time&lt;br&gt;
#assumes connected with USB. Drivers are installed. Needs pyvisa for communication.&lt;br&gt;
# There is no need to use visa write command for SP2150. because all commands are ask type (you write something and get a confirmation back saying OK)&lt;br&gt;
# filter 1 is no filter&lt;br&gt;
# filter 2 is in 320 nm long pass filter&lt;br&gt;
# filter 3 is 590 long pass filter cutoff&lt;br&gt;
# filter 4 is 715 long pass filter&lt;br&gt;
# filter 5 is 1250 long pass filter&lt;br&gt;
#filter 6 is block&lt;/p&gt;
&lt;p&gt;class SP2150i():&lt;br&gt;
def __init__(self):&lt;br&gt;
#self.m=instrument(get_instruments_list()[0])&lt;br&gt;
try:&lt;br&gt;
print get_instruments_list()&lt;br&gt;
self.m=instrument('COM7', timeout = 10) #he default timeout is 5 sec, change the timeout if needed&lt;br&gt;
except:&lt;br&gt;
print "Check if monochromotor is connected to right COM port of instrument list (see control panel, hardward devices). Cannot connect to monochromator. Check connection. Check drivers"&lt;/p&gt;
&lt;p&gt;def get_nm(self):&lt;br&gt;
self.curr_nm=self.m.ask_for_values('?NM')&lt;br&gt;
return self.curr_nm&lt;/p&gt;
&lt;p&gt;def get_nm_per_min(self):&lt;br&gt;
self.curr_nm_min=self.m.ask_for_values('?NM/MIN')&lt;br&gt;
return self.curr_nm_min&lt;/p&gt;
&lt;p&gt;def get_serial_model(self):&lt;br&gt;
self.serial_no=self.m.ask_for_values('SERIAL')&lt;br&gt;
self.model_no=self.m.ask_for_values('MODEL')&lt;br&gt;
return self.serial_no,self.model_no&lt;/p&gt;
&lt;p&gt;def goto_nm_max_speed(self,nm):&lt;br&gt;
self.m.ask('%0.2f GOTO' % nm)&lt;/p&gt;
&lt;p&gt;def get_turret(self):&lt;br&gt;
self.turret=self.m.ask_for_values('?TURRET')&lt;br&gt;
return self.turret&lt;/p&gt;
&lt;p&gt;def get_filter(self):&lt;br&gt;
self.filter=self.m.ask_for_values('?FILTER')&lt;br&gt;
time.sleep(2)&lt;br&gt;
return self.filter&lt;/p&gt;
&lt;p&gt;def get_grating(self):&lt;br&gt;
self.grating=self.m.ask_for_values('?GRATING')&lt;br&gt;
return self.grating&lt;/p&gt;
&lt;p&gt;def set_turret(self,num):&lt;br&gt;
if num &amp;lt;=2:&lt;br&gt;
self.m.ask(str(int(num))+ ' TURRET')&lt;br&gt;
else:&lt;br&gt;
print "There is not turret with this input"&lt;/p&gt;
&lt;p&gt;def set_filter(self,num):&lt;br&gt;
if num &amp;lt;=6:&lt;br&gt;
self.m.ask(str(int(num))+ ' FILTER')&lt;br&gt;
print "Filter changed and waiting with additional delay..."&lt;br&gt;
time.sleep(1) # Additional delay, just in case.&lt;br&gt;
print "Done waiting"&lt;br&gt;
else:&lt;br&gt;
print "There is no filter with this input"&lt;/p&gt;
&lt;p&gt;def set_grating(self,num):&lt;br&gt;
if num&amp;lt;=2:&lt;br&gt;
self.m.ask(str(int(num))+ ' GRATING')&lt;br&gt;
#time.sleep(5) # Additional delay, just in case&lt;br&gt;
else:&lt;br&gt;
print "There is no grating with this input"&lt;/p&gt;
&lt;p&gt;def goto_nm_with_set_nm_per_min(self,nm,nm_per_min):&lt;br&gt;
self.m.ask('%0.2f NM/MIN' % nm_per_min)&lt;br&gt;
self.m.ask('%0.2f &amp;gt;NM' % nm)&lt;br&gt;
char=0&lt;br&gt;
while char!=1:&lt;br&gt;
s=self.m.ask('MONO-?DONE')&lt;br&gt;
char=int(s[2])&lt;br&gt;
#print "Current wavelength is "+ self.m.ask('?NM')&lt;br&gt;
time.sleep(.2)&lt;br&gt;
print "Scan done?: "+'yes' if char == 1 else 'No'&lt;br&gt;
self.m.ask('MONO-STOP')&lt;br&gt;
return self.m.ask_for_values('?NM')&lt;/p&gt;
&lt;p&gt;if __name__ == "__main__":&lt;br&gt;
#This part of the codes uses the SP2150i class to do a wavelength scan&lt;br&gt;
a=SP2150i()&lt;br&gt;
print a.get_serial_model()&lt;br&gt;
print a.get_grating()&lt;br&gt;
print a.get_filter()&lt;br&gt;
print a.get_nm_per_min()&lt;br&gt;
print a.get_nm()&lt;br&gt;
a.set_grating(2) # can only take 1 or 2 as input&lt;/p&gt;
&lt;p&gt;start_wave=500&lt;br&gt;
end_wave=1000&lt;br&gt;
delta_wave=20&lt;br&gt;
speed_nm_per_min=2000&lt;br&gt;
a.set_filter(2) # this applies the 320 nm filter in the beginning&lt;br&gt;
for i in xrange(start_wave,end_wave,delta_wave):&lt;br&gt;
print "----------------------------"&lt;br&gt;
print "Wavelength input is %0.2f nm" % i&lt;br&gt;
wave=a.goto_nm_with_set_nm_per_min(i,speed_nm_per_min)&lt;/p&gt;
&lt;p&gt;if i &amp;lt;= 370 and i+delta_wave &amp;gt;= 370:&lt;br&gt;
a.set_filter(2)&lt;/p&gt;
&lt;p&gt;if i &amp;lt;= 660 and i+delta_wave &amp;gt;= 660:&lt;br&gt;
a.set_filter(3)&lt;/p&gt;
&lt;p&gt;if i &amp;lt;= 775 and i+delta_wave &amp;gt;= 775:&lt;br&gt;
a.set_filter(4)&lt;/p&gt;
&lt;p&gt;if i &amp;lt;= 1300 and i+delta_wave &amp;gt;= 1300:&lt;br&gt;
a.set_filter(5)&lt;/p&gt;
&lt;p&gt;print "Wavelength output is "+str(wave[0])+ " nm"&lt;br&gt;
print "----------------------------"&lt;/p&gt;
&lt;p&gt;print "Resetting the monochromator to home position"&lt;br&gt;
a.goto_nm_max_speed(400)&lt;br&gt;
a.set_filter(1)&lt;br&gt;
print "Position to home at " + str(a.get_nm()[0]) + " nm"+ ' and filter has been reset to ' + str(a.get_filter()[0])&lt;br&gt;
print "Monochromator scan done. Have a nice day!"&lt;/p&gt;
&lt;p&gt;[/cc]&lt;/p&gt;</content><category term="Test Equipment"></category></entry></feed>